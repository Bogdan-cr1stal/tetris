<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris</title>
  <style>
    body{margin:0; font-family:system-ui; display:flex; flex-direction:column; align-items:center; justify-content:center; height:100vh;}
    canvas{border:2px solid #333; touch-action:none;}
    .row{display:flex; gap:8px; margin-top:12px;}
    button{padding:10px 14px; font-size:16px;}
  </style>
</head>
<body>
  <canvas id="c" width="240" height="400"></canvas>
  <div class="row">
    <button id="left">‚¨ÖÔ∏è</button>
    <button id="rot">üîÑ</button>
    <button id="right">‚û°Ô∏è</button>
    <button id="down">‚¨áÔ∏è</button>
  </div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

const COLS = 10, ROWS = 20, SIZE = 20;
const board = Array.from({length: ROWS}, () => Array(COLS).fill(0));

const pieces = [
  // I
  [[1,1,1,1]],
  // O
  [[1,1],[1,1]],
  // T
  [[0,1,0],[1,1,1]],
  // L
  [[1,0],[1,0],[1,1]],
  // J
  [[0,1],[0,1],[1,1]],
  // S
  [[0,1,1],[1,1,0]],
  // Z
  [[1,1,0],[0,1,1]],
];

let p = spawn();

function spawn(){
  const shape = JSON.parse(JSON.stringify(pieces[Math.floor(Math.random()*pieces.length)]));
  return { shape, x: 3, y: 0 };
}

function rotate(mat){
  const h = mat.length, w = mat[0].length;
  const res = Array.from({length:w}, ()=>Array(h).fill(0));
  for(let r=0;r<h;r++) for(let c=0;c<w;c++) res[c][h-1-r]=mat[r][c];
  return res;
}

function collide(nx, ny, shape=p.shape){
  for(let r=0;r<shape.length;r++){
    for(let c=0;c<shape[r].length;c++){
      if(!shape[r][c]) continue;
      const x = nx + c, y = ny + r;
      if(x<0 || x>=COLS || y<0 || y>=ROWS) return true;
      if(board[y][x]) return true;
    }
  }
  return false;
}

function merge(){
  for(let r=0;r<p.shape.length;r++){
    for(let c=0;c<p.shape[r].length;c++){
      if(p.shape[r][c]){
        board[p.y+r][p.x+c]=1;
      }
    }
  }
}

function clearLines(){
  for(let r=ROWS-1;r>=0;r--){
    if(board[r].every(v=>v===1)){
      board.splice(r,1);
      board.unshift(Array(COLS).fill(0));
      r++;
    }
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // board
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(board[r][c]){
        ctx.fillRect(c*SIZE, r*SIZE, SIZE-1, SIZE-1);
      }
    }
  }
  // piece
  for(let r=0;r<p.shape.length;r++){
    for(let c=0;c<p.shape[r].length;c++){
      if(p.shape[r][c]){
        ctx.fillRect((p.x+c)*SIZE, (p.y+r)*SIZE, SIZE-1, SIZE-1);
      }
    }
  }
}

function tick(){
  if(!collide(p.x, p.y+1)){
    p.y++;
  } else {
    merge();
    clearLines();
    p = spawn();
    if(collide(p.x, p.y)) {
      // game over
      for(let r=0;r<ROWS;r++) board[r].fill(0);
      p = spawn();
    }
  }
  draw();
}

setInterval(tick, 350);

function move(dx, dy){
  const nx = p.x+dx, ny = p.y+dy;
  if(!collide(nx, ny)){ p.x=nx; p.y=ny; draw(); }
}

function doRotate(){
  const rs = rotate(p.shape);
  if(!collide(p.x, p.y, rs)){ p.shape=rs; draw(); }
}

document.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft') move(-1,0);
  if(e.key==='ArrowRight') move(1,0);
  if(e.key==='ArrowDown') move(0,1);
  if(e.key==='ArrowUp') doRotate();
});

left.onclick = ()=>move(-1,0);
right.onclick = ()=>move(1,0);
down.onclick = ()=>move(0,1);
rot.onclick = ()=>doRotate();

draw();
</script>
</body>
</html>
